# Bedrock Cost Optimization Best Practices

This guide provides comprehensive strategies for optimizing AWS Bedrock costs while maintaining high-quality AI analysis in the FinOps AI Agent system.

## Overview

AWS Bedrock pricing is based on:
- **Input tokens**: Text sent to the model
- **Output tokens**: Text generated by the model
- **Model type**: Different models have different pricing tiers

Understanding these factors is crucial for cost optimization.

## Cost Structure Analysis

### Titan Model Pricing (as of 2024)

| Model | Input Tokens (per 1K) | Output Tokens (per 1K) | Use Case |
|-------|----------------------|------------------------|----------|
| Titan Text Lite | $0.0003 | $0.0004 | Basic analysis |
| Titan Text Express | $0.0008 | $0.0016 | Balanced performance |
| Claude v2 | $0.008 | $0.024 | Premium analysis |

### Cost Calculation Example

```typescript
// Example cost calculation for 1000 API calls per month
const monthlyUsage = {
  apiCalls: 1000,
  avgInputTokens: 500,
  avgOutputTokens: 300,
  model: 'titan-text-express'
};

const monthlyCost = 
  (monthlyUsage.apiCalls * monthlyUsage.avgInputTokens / 1000 * 0.0008) +
  (monthlyUsage.apiCalls * monthlyUsage.avgOutputTokens / 1000 * 0.0016);

// Result: ~$0.88/month for 1000 calls
```

## Optimization Strategies

### 1. Model Selection Optimization

#### Choose the Right Model for Your Use Case

```typescript
// Cost-optimized configuration for basic insights
const basicConfig: BedrockConfig = {
  modelId: 'amazon.titan-text-lite-v1',
  maxTokens: 400,
  temperature: 0.2,
  costThreshold: 25
};

// Balanced configuration for regular use
const standardConfig: BedrockConfig = {
  modelId: 'amazon.titan-text-express-v1',
  maxTokens: 800,
  temperature: 0.3,
  costThreshold: 75
};

// Premium configuration for detailed analysis
const premiumConfig: BedrockConfig = {
  modelId: 'anthropic.claude-v2',
  maxTokens: 1200,
  temperature: 0.4,
  costThreshold: 200
};
```

#### Model Selection Decision Matrix

| Requirement | Recommended Model | Monthly Cost Estimate |
|-------------|------------------|----------------------|
| Basic anomaly detection | Titan Text Lite | $5-15 |
| Standard cost analysis | Titan Text Express | $15-50 |
| Detailed optimization | Claude v2 | $50-150 |
| High-frequency monitoring | Titan Text Lite | $25-75 |

### 2. Token Usage Optimization

#### Optimize Input Tokens

```typescript
// Inefficient: Sending raw cost data
const inefficientPrompt = `
Analyze this complete cost data: ${JSON.stringify(fullCostData)}
Provide insights and recommendations.
`;

// Efficient: Preprocessed and summarized data
const efficientPrompt = `
Analyze AWS costs:
- Total: $${totalCost}
- Top 3 services: ${topServices.map(s => `${s.name}: $${s.cost}`).join(', ')}
- Month-over-month change: ${changePercent}%
- Unusual patterns: ${anomalies.join(', ')}

Provide specific optimization recommendations.
`;
```

#### Optimize Output Tokens

```typescript
// Request structured, concise responses
const structuredPrompt = `
Analyze the cost data and respond in this exact format:
1. Key Finding: [one sentence]
2. Top Anomaly: [service name and percentage increase]
3. Primary Recommendation: [specific action]
4. Confidence: [0-100]

Cost Data: ${costSummary}
`;
```

#### Token Reduction Techniques

1. **Data Preprocessing**
   ```typescript
   // Summarize cost data before sending to Bedrock
   const summarizeCostData = (costData: CostAnalysis) => ({
     totalCost: costData.totalCost,
     topServices: costData.serviceBreakdown
       .sort((a, b) => b.cost - a.cost)
       .slice(0, 5), // Only top 5 services
     changePercent: calculateMonthOverMonthChange(costData),
     significantChanges: identifySignificantChanges(costData)
   });
   ```

2. **Template-Based Prompts**
   ```typescript
   const promptTemplates = {
     anomalyDetection: `Detect anomalies in: {costSummary}. Format: service|severity|confidence`,
     optimization: `Optimize costs for: {topServices}. Format: service|action|savings`,
     summary: `Summarize: {totalCost}, {changePercent}%. Format: insight|recommendation`
   };
   ```

3. **Conditional Analysis**
   ```typescript
   // Only use AI for significant changes
   const shouldUseAI = (costData: CostAnalysis) => {
     const changePercent = calculateChange(costData);
     const hasAnomalies = detectSimpleAnomalies(costData);
     
     return changePercent > 10 || hasAnomalies.length > 0;
   };
   ```

### 3. Caching Strategies

#### Intelligent Caching

```typescript
const cacheConfig = {
  // Cache based on cost data similarity
  generateCacheKey: (costData: CostAnalysis) => {
    const rounded = Math.round(costData.totalCost / 10) * 10; // Round to nearest $10
    const topService = costData.serviceBreakdown[0]?.service || 'none';
    return `bedrock-${rounded}-${topService}-${getDateKey()}`;
  },
  
  // Longer cache for stable patterns
  dynamicTTL: (costData: CostAnalysis) => {
    const volatility = calculateCostVolatility(costData);
    return volatility < 0.1 ? 120 : 30; // 2 hours vs 30 minutes
  }
};
```

#### Multi-Level Caching

```typescript
class BedrockCacheManager {
  private memoryCache = new Map();
  private redisCache: RedisClient;
  
  async getCachedAnalysis(key: string): Promise<AIAnalysisResult | null> {
    // Level 1: Memory cache (fastest)
    if (this.memoryCache.has(key)) {
      return this.memoryCache.get(key);
    }
    
    // Level 2: Redis cache (fast)
    const cached = await this.redisCache.get(key);
    if (cached) {
      this.memoryCache.set(key, cached);
      return cached;
    }
    
    return null;
  }
}
```

### 4. Rate Limiting and Throttling

#### Adaptive Rate Limiting

```typescript
class AdaptiveRateLimiter {
  private currentCost = 0;
  private monthlyBudget: number;
  
  calculateAllowedRate(): number {
    const remainingBudget = this.monthlyBudget - this.currentCost;
    const daysRemaining = getDaysRemainingInMonth();
    const dailyBudget = remainingBudget / daysRemaining;
    
    // Adjust rate based on remaining budget
    if (dailyBudget < 1) return 1; // Minimum 1 call per minute
    if (dailyBudget < 5) return 3;
    return 10; // Normal rate
  }
}
```

#### Cost-Based Throttling

```typescript
const costBasedConfig = {
  // Reduce frequency as costs increase
  getRateLimit: (currentCost: number, threshold: number) => {
    const utilizationPercent = (currentCost / threshold) * 100;
    
    if (utilizationPercent > 90) return 1; // Emergency mode
    if (utilizationPercent > 75) return 3; // Conservative mode
    if (utilizationPercent > 50) return 5; // Reduced mode
    return 10; // Normal mode
  }
};
```

### 5. Prompt Engineering for Efficiency

#### Efficient Prompt Templates

```typescript
const efficientPrompts = {
  // Concise anomaly detection
  anomalyDetection: `
    Cost Analysis - Detect anomalies:
    Services: {serviceList}
    Changes: {changeList}
    
    Output format: [service]|[severity:LOW/MED/HIGH]|[confidence:0-100]
    Max 3 anomalies.
  `,
  
  // Focused optimization
  optimization: `
    Optimize top costs:
    1. {service1}: ${cost1}
    2. {service2}: ${cost2}
    3. {service3}: ${cost3}
    
    Format: [service]|[action]|[estimated_savings]
    One recommendation per service.
  `,
  
  // Summary analysis
  summary: `
    Cost Summary:
    Total: ${total} (${change}% vs last month)
    Alert: ${alertLevel}
    
    Provide: 1 key insight, 1 recommendation (max 50 words each)
  `
};
```

#### Context-Aware Prompting

```typescript
const contextAwarePrompt = (costData: CostAnalysis, context: AnalysisContext) => {
  // Adjust prompt complexity based on cost significance
  if (costData.totalCost < 100) {
    return efficientPrompts.summary;
  } else if (costData.totalCost < 1000) {
    return efficientPrompts.anomalyDetection;
  } else {
    return efficientPrompts.optimization;
  }
};
```

### 6. Batch Processing and Aggregation

#### Batch Multiple Analyses

```typescript
class BatchProcessor {
  private pendingAnalyses: CostAnalysis[] = [];
  private batchSize = 5;
  
  async addAnalysis(costData: CostAnalysis): Promise<AIAnalysisResult> {
    this.pendingAnalyses.push(costData);
    
    if (this.pendingAnalyses.length >= this.batchSize) {
      return this.processBatch();
    }
    
    // Return cached or simplified analysis for small batches
    return this.getSimplifiedAnalysis(costData);
  }
  
  private async processBatch(): Promise<AIAnalysisResult> {
    const aggregatedData = this.aggregateCostData(this.pendingAnalyses);
    const result = await this.bedrockTool.analyzeSpendingPatterns(aggregatedData);
    
    this.pendingAnalyses = [];
    return result;
  }
}
```

### 7. Fallback and Hybrid Approaches

#### Smart Fallback Strategy

```typescript
class HybridAnalyzer {
  async analyzeWithFallback(costData: CostAnalysis): Promise<EnhancedCostAnalysis> {
    // Use traditional analysis first
    const basicAnalysis = await this.traditionalAnalysis(costData);
    
    // Only use AI for complex scenarios
    if (this.shouldUseAI(costData, basicAnalysis)) {
      try {
        const aiAnalysis = await this.bedrockAnalysis(costData);
        return this.combineAnalyses(basicAnalysis, aiAnalysis);
      } catch (error) {
        // Fallback to enhanced traditional analysis
        return this.enhancedTraditionalAnalysis(basicAnalysis);
      }
    }
    
    return basicAnalysis;
  }
  
  private shouldUseAI(costData: CostAnalysis, basicAnalysis: any): boolean {
    return (
      costData.totalCost > 500 || // High-value accounts
      basicAnalysis.anomalies.length > 2 || // Complex anomalies
      basicAnalysis.changePercent > 25 // Significant changes
    );
  }
}
```

### 8. Cost Monitoring and Alerting

#### Real-Time Cost Tracking

```typescript
class BedrockCostMonitor {
  private dailyCosts = new Map<string, number>();
  
  async trackAPICall(inputTokens: number, outputTokens: number, modelId: string) {
    const cost = this.calculateCallCost(inputTokens, outputTokens, modelId);
    const today = new Date().toISOString().split('T')[0];
    
    const currentDailyCost = this.dailyCosts.get(today) || 0;
    this.dailyCosts.set(today, currentDailyCost + cost);
    
    // Check thresholds
    await this.checkCostThresholds(currentDailyCost + cost);
  }
  
  private async checkCostThresholds(dailyCost: number) {
    const monthlyProjection = dailyCost * 30;
    
    if (monthlyProjection > this.config.costThreshold * 0.8) {
      await this.sendCostWarning(monthlyProjection);
    }
    
    if (monthlyProjection > this.config.costThreshold) {
      await this.disableBedrockTemporarily();
    }
  }
}
```

#### Cost Optimization Alerts

```typescript
const costOptimizationAlerts = {
  // Daily cost review
  dailyReview: {
    threshold: 5, // $5/day
    action: 'review_usage_patterns'
  },
  
  // Weekly optimization check
  weeklyOptimization: {
    threshold: 25, // $25/week
    action: 'optimize_prompts_and_caching'
  },
  
  // Monthly budget alert
  monthlyBudget: {
    threshold: 80, // 80% of monthly budget
    action: 'reduce_rate_limits'
  }
};
```

## Cost Optimization Configurations

### Startup/Small Business (< $50/month)

```typescript
const startupConfig: BedrockConfig = {
  enabled: true,
  modelId: 'amazon.titan-text-lite-v1',
  maxTokens: 300,
  temperature: 0.1,
  costThreshold: 15,
  rateLimitPerMinute: 2,
  cacheResults: true,
  cacheTTLMinutes: 180, // 3 hours
  fallbackOnError: true
};
```

### Medium Business ($50-200/month)

```typescript
const mediumConfig: BedrockConfig = {
  enabled: true,
  modelId: 'amazon.titan-text-express-v1',
  maxTokens: 600,
  temperature: 0.2,
  costThreshold: 75,
  rateLimitPerMinute: 5,
  cacheResults: true,
  cacheTTLMinutes: 90,
  fallbackOnError: true
};
```

### Enterprise ($200+/month)

```typescript
const enterpriseConfig: BedrockConfig = {
  enabled: true,
  modelId: 'amazon.titan-text-express-v1',
  maxTokens: 1000,
  temperature: 0.3,
  costThreshold: 300,
  rateLimitPerMinute: 15,
  cacheResults: true,
  cacheTTLMinutes: 60,
  fallbackOnError: true
};
```

## Monitoring and Optimization Tools

### Cost Analysis Dashboard

```typescript
const costMetrics = {
  // Track cost per analysis
  costPerAnalysis: 'BedrockCostUSD / BedrockApiCalls',
  
  // Monitor token efficiency
  tokenEfficiency: 'BedrockTokensUsed / BedrockApiCalls',
  
  // Cache effectiveness
  cacheEffectiveness: 'BedrockCacheHitRate * 100',
  
  // Cost trend analysis
  costTrend: 'BedrockCostUSD (7-day moving average)'
};
```

### Optimization Recommendations Engine

```typescript
class OptimizationEngine {
  async generateRecommendations(usage: UsageMetrics): Promise<OptimizationRecommendation[]> {
    const recommendations = [];
    
    // High cost per call
    if (usage.costPerCall > 0.05) {
      recommendations.push({
        type: 'model_optimization',
        description: 'Consider switching to Titan Text Lite for basic analysis',
        potentialSavings: usage.monthlyCost * 0.4
      });
    }
    
    // Low cache hit rate
    if (usage.cacheHitRate < 0.6) {
      recommendations.push({
        type: 'caching_optimization',
        description: 'Improve caching strategy to reduce API calls',
        potentialSavings: usage.monthlyCost * 0.3
      });
    }
    
    // High token usage
    if (usage.avgTokensPerCall > 800) {
      recommendations.push({
        type: 'prompt_optimization',
        description: 'Optimize prompts to reduce token usage',
        potentialSavings: usage.monthlyCost * 0.25
      });
    }
    
    return recommendations;
  }
}
```

## Implementation Checklist

### Initial Setup
- [ ] Choose appropriate model based on use case and budget
- [ ] Set conservative cost thresholds initially
- [ ] Implement comprehensive caching strategy
- [ ] Configure rate limiting based on budget

### Ongoing Optimization
- [ ] Monitor daily/weekly cost trends
- [ ] Review and optimize prompts monthly
- [ ] Analyze cache hit rates and adjust TTL
- [ ] Evaluate model performance vs. cost quarterly

### Cost Control Measures
- [ ] Set up CloudWatch alarms for cost thresholds
- [ ] Implement automatic disabling at budget limits
- [ ] Regular review of usage patterns and optimization opportunities
- [ ] Document cost optimization decisions and results

## ROI Calculation

### Measuring AI Analysis Value

```typescript
const calculateROI = (aiCosts: number, traditionalCosts: number, benefits: Benefits) => {
  const costSavingsFromOptimization = benefits.identifiedSavings;
  const timesSavedFromAutomation = benefits.hoursAutomated * benefits.hourlyRate;
  const improvedDecisionMaking = benefits.betterInsights * benefits.decisionValue;
  
  const totalBenefits = costSavingsFromOptimization + timesSavedFromAutomation + improvedDecisionMaking;
  const netCost = aiCosts - traditionalCosts;
  
  return (totalBenefits - netCost) / netCost;
};
```

### Example ROI Scenarios

| Scenario | Monthly AI Cost | Identified Savings | Time Saved | ROI |
|----------|----------------|-------------------|------------|-----|
| Small Business | $15 | $200 | 5 hours | 800% |
| Medium Business | $75 | $1,500 | 20 hours | 1,200% |
| Enterprise | $300 | $10,000 | 50 hours | 2,000% |

This cost optimization guide should be reviewed and updated regularly as Bedrock pricing and features evolve.